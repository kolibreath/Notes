# empty()
Observable empty will emit no event, 
````
 Observable.empty()
                .subscribe(observable -> {
                    System.out.print("Fd");
                });
````
nothing subscribes, nothing prints!

and combine with the ``first()``Operator, 
````

        Observable.empty().first()
                .subscribe(observable -> {
                    System.out.print("Fd");
                }); 
````
The stream is empty, so a unchecked error will be thrown out!

To be short, the first() operator will not take empty event (generated by empty() operator, but first can take empty events wrapped by just()).So 

this pattern can be used for error handling :
````
Observable
    .create(subscriber->{Observable.error(())})
    //first arg: the events will be sent out normally wrapped by just
    //second arg: the default events , if there is not error notification
    //third arg: upStream completes normally
    .flatmap(Observable::just,th->Observable::empty,Observable::empty)
    //the real observable of events when error occurs
    .concatWith(something ...)
    //the first() will filter "empty" events
    .first();
````

# debounce() 
filter when Observable emits events too fast
# first()