###  defer()    :
[Value deferring](http://blog.danlew.net/2015/07/23/deferring-observable-code-until-subscription-in-rxjava/)

````
just() from() and other Observable creation tools stores the value of data when created not when subscribed.
````

from the blog above we got some Solutions:

- using create(): 
- using defer() and fromCallable() : defer can delay (especially the intialization) whatever in the lambda expression util someone subscribe to it.

I also found this expression [here](https://caster.io/lessons/fromcallable-converting-slow-methods-into-an-observable)

````
String value = Database.readValue();
Observable.just(value);
````
Though just() returns cold observable, the just() and from() method will not keep waiting for the subscribe() calling, the just() operator saves whatever currently. The data can be out of date.

# empty()
Observable empty will emit no event, 
````
 Observable.empty()
                .subscribe(observable -> {
                    System.out.print("Fd");
                });
````
nothing subscribes, nothing prints!

and combine with the ``first()``Operator, 
````

        Observable.empty().first()
                .subscribe(observable -> {
                    System.out.print("Fd");
                }); 
````
The stream is empty, so a unchecked error will be thrown out!

To be short, the first() operator will not take empty event (generated by empty() operator, but first can take empty events wrapped by just()).So 

this pattern can be used for error handling :
````
Observable
    .create(subscriber->{Observable.error(())})
    //first arg: the events will be sent out normally wrapped by just
    //second arg: the default events , if there is not error notification
    //third arg: upStream completes normally
    .flatmap(Observable::just,th->Observable::empty,Observable::empty)
    //the real observable of events when error occurs
.concatWith(something ...)
    //the first() will filter "empty" events
    .first();
````

When I apply this approach into my code, I found that only when  the source events and events in concatWith() are from the same type, the approach actually works well:

````
SomeType{
    int errorEvents();

    int wellEvents();
}
````  


By doing so, using the same subscribe(), the downStream can process the different event streams with the same logic.



# debounce() 

filter when Observable emits events too fast


# first()
like take(1) but will filter "empty" events

# retry() Family
````
 Observable.create(subscriber -> {
            throw new RuntimeException();
        })
                .retry(1000000000)
                .doOnError(throwable -> System.out.print("fuck\n"))
                .subscribe(new Subscriber<Object>() {
                    @Override
                    public void onCompleted() {

                    }

                    @Override
                    public void onError(Throwable throwable) {
                        throwable.printStackTrace();
                        System.out.print(count-- + " ");
                    }

                    @Override
                    public void onNext(Object o) {

                    }
                });
````
plain ``retry()`` without parameters with resubscribe to the event and push it downstream without sending notification to onError(), until the last exception is caught in the stream.

in this dramatic code snippet, I let RxJava retry for many times, the code did response after  a quite a long time.

``retryWhen()`` behaves differently as it sounds, it should be named when retry. This operator takes a Func as a parameter.
````
retryWhen(x->x.delay(10 sec))
````