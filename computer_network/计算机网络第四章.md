# 第四章 运输层
## 运输层的重要概念

- 运输层为相互通信的应用进程提供逻辑通信
- 端口和套接字的意义
- 无链接的UDP的特点
- 面向连接的TCP的特点
- 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议
- TCP的滑动窗口 流量控制 拥塞控制 连接管理
- 运输层检验IP数据报的数据部分

## 运输层的两个主要协议
- 用户数据报协议 UDP
    - UDP数据报
- 传输控制协议   TCP
    - TCP 报文段
    - TCP不提供广播 多播 
- 运输层 具有分用和复用的功能
![TCP UDP 应用使用的协议](https://upload-images.jianshu.io/upload_images/4714178-e1eb97872894c0c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 协议端口号
- 协议端口号的使用背景<br>
需要使用一个和操作系统无关的，非进程标识符的方法标识进程。
- 常见的熟知端口号

|应用程序|FTP|TELNET|SMTP|DNS|TFTP|HTTP|SNMP|SNMP trap|HTTPS|
|:--------:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|熟知端口号|21|23|25|53|69|80|161|162|443|
- 登记端口号<br>
1024-49151
- 短暂端口号<br>
49152-65535

### 用户数据报协议 UDP
- UDP的主要特点
    - 无连接
    - 尽最大努力交付
    - 面向报文<br>
    UDP一次发送一个报文，在IP层如果用户主机没有选择合适的报文，IP层在传输的的时候需要报文分片，会使IP首部相对长度太大
    - UDP没有拥塞控制<br>
    网络出现的拥塞不会是源主机的发送速率降低，允许在网络发生功能拥塞时丢失一些数据
    - UDP<br> 
    支持一对一 ，一对多 ，多对一 和， 多对多交互通信
    - UDP<br>
     首部开销小 八个字节

### UDP的首部格式
![UDP 首部格式](https://upload-images.jianshu.io/upload_images/4714178-a13f6c905125d475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
虽然伪首部不向下传输到IP层，但是从IP层可以获取到伪首部中的字段，从IP数据报中提取，这样接收方就可以对首部进行检验。

### TCP 传输协议控制
- TCP协议的主要特点
    - 面向连接的传输层协议<br>
    使用之前建立TCP连接，传输数据完毕后释放TCP连接
    - 端点<br>
    - TCP提供可靠交付
    - TCP 全双工通信 <br>
    - 面向字节流
- TCP的连接<br>
TCP连接的端口是socket后者称之为插口：IP地址拼接端口

## TCP 如何使传输变得可靠
- 可靠的依据
    - 传输信道不产生差错
    - 不管发送方以多快的数据发送数据，接收方总是来得及处理收到的数据

### 停止等待协议
- 通常的情况
    - 正常传输和获得收到消息
    - 发送分组错误 重新传送分组
![停止等待协议](https://upload-images.jianshu.io/upload_images/4714178-f96adfea21aa231c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 另外的情况
    - 确认丢失
    - 确认迟到
![](https://upload-images.jianshu.io/upload_images/4714178-bf32338732c67409.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 如何提高发送率？
流水线传输：
![流水线传输](https://upload-images.jianshu.io/upload_images/4714178-4be84f3122511e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


## 连续ARQ协议
连续发送N个分组，然后使用``累积确认``的方式：接收方不必对每个分组组个发送确认，而是在收到几个分组后，对按需到达的最后一个分组发送确认
- 优点
    - 确认丢失也不必重传
    - 容易实现
- 缺点 
    - 不能向发送方发送接受方已经收到所有分组的信息

## TCP报文段
- 首部格式
    - 源端口
    - 目的端口
- 序号 <br>
本报文段所发送的数据的第一个字节的序号
- 确认号<br>
期望收到的对方下一个报文段的第一个数据自己的序号，确认号为N表示序号
N-1的数据都已经正确接受到。
- 数据偏移
TCP报文段数据字段距离TCP报文段的起始处。
- 保留
- 紧急
- 确认
- 推送
接收方收到了PSH=1的报文段不需要等到整个缓存都满了再向上交付
- 复位
RST = 1 表明TCP连接中出现严重差错，需要释放连接。<br>
- 同步
- 终止
- 窗口
- 检验和
需要加上伪首部
- 紧急指针
- 选项


## TCP 可靠传输的实现
- 滑动窗口算法<br>
滑动窗口算法主要是通过窗口来确认可靠传输是不是在执行：<br>
发送方A 如果发送的内容而且得到了确认，发送的字节的序号才会继续增长。同时接收方也是，只有字节收到了之后并且交付给自己的方面的·接受进程才可以继续移动接受窗口。
- 需要区分的概念
    - 可用窗口
    - 接收窗口
    - 发送窗口

- 发送缓存和发送窗口有区别
![](https://upload-images.jianshu.io/upload_images/4714178-79f7226c038a9a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 发送缓存用来存放
    - 发送应用程序给发送方TCP的数据
    - TCP已经发送但是尚未收到确认的数据
- 接受缓存用来存放
    - 暂时没有被接收应用程序读取的数据
    - 没有按序到达的数据
- TCP 是全双工通信

## 超时重传时间选择
TCP使用一个自适应算法<br>
一个报文段发出的时间和收到相应确认的时间，两个时间之差就是报文段的往返时间RTT，实际过程中使用的是  ``平滑RTTS``

- 关于平滑RTT 和 RTO的计算   
    - 重复的确认的问题
    解决方法：Karn算法和修正算法

### 选择确认SACK
收到的报文段没有差错但是没有按照序号，中间还有缺少的数据，能否在发送方只重传缺少的数据？（因为这些内容在发送窗口内部，如果不采用某种机制解决这个问题的话，接收方无法发送确认报文，因为会按照收到的最小值发送报文）<br>
如果要使用选择确认SACK，需要在TCP首部中加入允许SACK<br>
SACK文档没指明发送方如何响应SACK，大多数的实现还是使用重传机制。

## TCP流量控制
- 流量控制如何实现<br>
B向A发送控制信息，还可以继续发送多少字节等
- 滑动窗口实现流量控制
![滑动窗口流量控制](https://upload-images.jianshu.io/upload_images/4714178-df7066df3d34f1d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 可能出现的死锁情况<br>
B向A发送的非零窗口请求丢失，然后A一直在等待B的非零窗口，而B也在等A的数据<br>
TCP设置了个一个持续连接器，收到零窗口通知的哪一方会在定时器结束后发送``零窗口探测``

### TCP的传输效率
应用进程将数据发送到TCP发送缓存，剩下用TCP控制，有以下几种机制控制TCP报文段的发送时机
- 最大报文长度<br>
如果发送缓存中的内容达到了最大发送长度，就会被封装成一个TCP报文段发送出去
- TCP的Push 操作
- 发送方的计时器指定发送

### 傻瓜窗口问题
- 什么是傻瓜窗口问题<br>
发送方发送数据很慢，或者接收方处理数据速度很慢，造成在有效载荷一个字节的情况下,而传输开销有40字节（IP头20字节，TCP头20字节）
- 傻瓜窗口的一个例子<br>
接受窗口的读取进程每次只会读取一字节的内容，接收方在窗口满的情况下，经常只能有一个字节的空闲。<br>
于是将发送窗口的大小也设置为1，于是在网络中两方只能一个字节一个字节的传输。
- 解决方法
    - 在发送端引起的傻瓜窗口综合征（发送端发送数据比较慢）
        - 强迫发送方等待一段时间，收集一部分发送数据
    - 在接收端引起的傻瓜综合征
        - 发送窗口大小为0的报文，暂停发送方的发送。等到接受方处理到MTU
        的一半的时候再允许发送方发送数据。 
        - 延迟确认报文的发送，减缓发送方滑动窗口的滑动速度。

## TCP拥塞控制

> 拥塞：对网络上资源的 ``需求`` > ``可用资源``
- 可能造成网络拥塞的因素：
    - 节点缓存太大<br>
    到达节点的分组都可以排队，但是处理机的速度没有提高，排队时间增加
    - 节点缓存太小<br>
    不能放入的节点丢弃，造成重传
    - 处理机的速度太慢
- TCP具体的拥塞控制方法
    - 慢开始
    - 拥塞避免
    - 快重传
    - 快恢复
- 判断网络发生拥塞的依据
如果发送方有1%的分组没有在规定的时间内收到确认

![屏幕快照 2019-06-11 10.56.54.png](https://upload-images.jianshu.io/upload_images/4714178-7bfb17eca5d6f866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 慢开始算法和拥塞避免
1. 发送方维持一个``拥塞窗口``，大小为1，这个拥塞窗口的大小和发送窗口一样<br>
![发送方法流程图](https://upload-images.jianshu.io/upload_images/4714178-64a23c18d32ace81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
发送方每收到一个队发送报文的``确认``就会将``发送窗口增加1``，不需要等到这个发送轮次的所有报文都得到回复<br>
2. 为了避免拥塞窗口的大小cwnd增长过大，需要使用慢启动门限值ssthresh 和拥塞避免的方法。每次一个``RTT``都会使cwnd +1 
3. 超时的时候，将慢启动门限调整至一半（ssthresh = cwnd / 2）的大小，然后设置cwnd为1

- 快重传
![快重传的示意图](https://upload-images.jianshu.io/upload_images/4714178-a2ae2efd3e4a2d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
一连发送三个M2的确认报文可以让发送方知道接受方丢失了M3,发送方不会误认为发生了网络拥塞
- 快重传想解决的问题<br>
如果报文段在网络中丢失，发送方有可能认为这个是由于网络拥塞导致的(但是其实不是)，可能会减小发送窗口<br>
如果收到一连三个对某个分组的确认信息说明这个分组可能丢失

- 快恢复算法<br>
M3丢失，接收方在接受后面的分组的时候提示需要重传M3，然后将cwnd = ssthresh / 2

- 加法增大Ai 和 乘法减小 MD 合称为AIMD算法
![算法流程图](https://upload-images.jianshu.io/upload_images/4714178-4c9ace81dfd06fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 通知窗口
接收方窗口也称为通知窗口，所以发送方窗口的上限 = min{rwnd, cwnd}

## 网络层采取的策略
网络层路由器可能处理分组的时间比较长，这样会造成发送方重传，这些IP数据报在路由器中通过队列的方法存储，如果队列缓存存储不下的话，会将队列末尾的多条IP数据报丢弃，这样会导致可能不止一条TCP连接出现问题，然后使发送方都进入慢启动状态。

- 主动管理队列 ARQ<br>
在察觉到队列长度到某个可能值得时候就丢弃后面的分组
- RED 早期随机检测<br>
RED保存一个最小门限和最大门限，同时计算队列的平均长度，当在一个最大最小门限之间的时候按照一定的概率丢弃后面的分组

## TCP的运输管理
- TCP的连接建立
### TCP 三次握手
- TCP的三次握手
![三次握手](https://upload-images.jianshu.io/upload_images/4714178-b402cf143913d8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 为什么还需要发送最后一个确认<br>
如果A发送的第一次请求B连接在网络中滞留过久，之后A又重新发送请求并且建立正确的连接，并且正常地关闭了连接。这个时候第一次发送的连接到了B，B在一直等A的数据，会浪费数据。
### TCP 四次释放
- TCP四次释放
![四次握手](https://upload-images.jianshu.io/upload_images/4714178-735bbb3f09095030.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
防止网络中还有 已失效的连接报文段

- TCP 服务端
TCP服务端有一二保活计时器，如果服务端主机突然出现故障，服务端会关闭连接

 